# JVM虚拟机技术

## 1、垃圾收集器

### 1.1、选择正确的垃圾收集器有多么重要

[Oracle官方](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/introduction.html)向我们描述了一个非常理想的系统建模，在在应对垃圾回收时对系统吞吐量的影响。若仅将1%的时间用于单处理器系统上的垃圾回收拓展至32个处理器，，系统的吞吐量损失将超过20%。对于垃圾回收占10%的应用程序，将其拓展至32个处理器时，系统的吞吐量将损失75%以上。如下图所示：

![Description of Figure 1-1 follows](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/img/jsgct_dt_005_gph_pc_vs_tp.png)

根据`amdahl定律`，特定问题中并行加速受问题顺序部分的限制，绝大多数工作的负载是不能完全并行化的，某些部分始终是串行的，并不会从并行中收益。对于1.4版本以前的JVM更是如此。

故我们在开发小型系统时，速度可以忽略不计的问题，可能会成为拓展到大型系统时的主要瓶颈。对于足够大的系统，选择正确的垃圾收集器，就变得至关重要。

串行收集器通常适用于大多数“小型”应用程序 (那些需要大约100MB的堆 ) 的应用程序。其他收集器具有额外的开销或复杂性， 这是专门行为的代价。如果应用程序不需要备用收集器的专用行为， 请使用串行收集器。串行收集器不应成为最佳选择的一种情况是在具有大量内存和两个或多个处理器的计算机上运行的大型、大量线程化的应用程序。在此类服务器类计算机上运行应用程序时， 默认情况下选择并行收集器。

### 1.2、垃圾收集器类型

- `串行收集器`：使用单线程来执行所有垃圾收集工作，线程之间没有通信开销，故相对高效。适用于单核计算机，因为此类型的收集器不能利用多核处理器硬件，但是该类型的收集器也适用于具有小型数据集（约100MB）的应用程序。显式的开启该收集器，则增加参数`-XX:+UseSerialGC`

- `并行收集器（又称吞吐量收集器）`：并行执行次要收集， 这可以显著降低垃圾收集开销。它适用于在多处理器或多线程硬件上运行的中型到大型数据集的应用程序。显式的开启该收集器，则增加参数`-XX:+UseParallelGC`

- `并行压缩收集器`：使并行收集器能够并行执行主要集合的功能。在没有并行压缩的情况下， 主要集合是使用单个线程执行的， 这可能会显著限制可伸缩性。如果已指定该选项， 则默认情况下启用并行压缩。关闭它的选项是`-XX:+UseParallelGC-XX:-UseParallelOldGC`

- `并发收集器`：大多数并发收集器同时执行其大部分工作 (例如， 在应用程序仍在运行时)，以保持垃圾收集暂停时间较短。它是为具有中型到大型数据集的应用程序而设计的， 在这些应用程序中， 响应时间比总体吞吐量更重要， 因为用于最大限度地减少暂停的技术可能会降低应用程序性能。java热点虚拟机提供了两个主要是并发的收集器之间的选择：`cms收集器`和`G1`收集器，可以参阅[主要并发收集器](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/concurrent.html#mostly_concurrent)。
  1. `cms收集器`：此收集器适用于喜欢较短的垃圾收集暂停并可承受与垃圾回收共享处理器资源的应用程序。`-XX:+UseConcMarkSweepGC`

  2. `G1收集器`：此服务器样式收集器适用于具有大内存的多处理器计算机。它以很高的概率满足垃圾收集暂停时间目标， 同时实现高吞吐量。`-XX:+UseG1GC`

### 1.3、如何选择正确的垃圾收集器

除非您的应用程序有相当严格的暂停时间要求，否则请首先运行应用程序并允许vm选择收集器。如有必要， 请调整堆大小以提高性能。如果性能仍然不能满足您的目标， 则使用以下准则作为选择收集器的起点。

- 如果应用程序有一个较小的数据集（约100MB），则选择具有该选项的串行收集器。`-XX:+UseSerialGC`
- 如果应用程序将在单个处理器上运行， 并且没有暂停时间要求， 则让 vm 选择收集器， 或选择带有该选项的串行收集器。`-XX:+UseSerialGC`
- 如果 (a) 应用程序的峰值性能是第一优先级， 并且 (b) 没有暂停时间要求或1秒或更长时间的暂停是可以接受的， 则让 vm 选择收集器， 或选择与之的并行收集器。`-XX:+UseParallelGC`
- 如果响应时间比总体吞吐量更重要， 并且垃圾收集暂停必须保持在大约1秒的时间内， 则选择使用或的并发收集器。`-XX:+UseConcMarkSweepGC`或`-XX:+UseG1GC`

这些准则仅提供了选择收集器的起点，因为性能取决于堆的大小、应用程序维护的实时数据量以及可用处理器的数量和速度。暂停时间对这些因素特别敏感，因此前面提到的1秒阈值只是近似值，在许多数据大小和硬件组合上，并行收集器的暂停时间将超过 1秒；相反， 并发收集器可能无法在某些组合上保持停顿时间短于1秒。

如果推荐的收集器未达到所需的性能，请首先尝试调整堆和生成大小，以满足所需的目标。如果性能仍然不足，请尝试使用其他收集器: 使用并发收集器减少暂停时间，并使用并行收集器增加多处理器硬件上的整体吞吐量。

## 2、代
[Oracle官方](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/generations.html)提供了一个对象寿命的典型分布，如下图所示：

![Description of Figure 3-1 follows](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/img/jsgct_dt_003_alc_vs_srvng.png)

从图中可以看出，有些对象寿命长，有些对象寿命短。所以内存的分代管理就显的尤为重要。若垃圾收集成为系统的瓶颈，则很可能必须通过自定义堆的总大小以及各个代的大小，并检查详细的垃圾收集器输出, 然后探索单个性能指标对垃圾回收器参数的敏感性。下图展示了JVM的分代模型（并行收集器和G1除外）。

![Description of Figure 3-2 follows](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/img/jsgct_dt_001_armgnt_gn.png)

在初始化时, 最大地址空间几乎是保留的, 但除非需要, 否则不会分配给物理内存。为对象记忆保留的完整地址空间可以分为年轻的一代和终身的一代。
年轻代由eden和两个幸存者空间组成。大多数对象最初是在eden中分配的。一个幸存者空间在任何时候都是空的, 是eden中任何活物的目的地;另一个幸存者空间是下一个复制集合期间的目标。对象以这种方式在幸存者空间之间复制, 直到它们足够老, 可以终身工作(复制到老年代)。