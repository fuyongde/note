# JVM虚拟机技术

## 1、垃圾收集器

### 1.1、选择正确的垃圾收集器有多么重要

​	[Oracle官方](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/introduction.html)向我们描述了一个非常理想的系统建模，在在应对垃圾回收时对系统吞吐量的影响。若仅将1%的时间用于单处理器系统上的垃圾回收拓展至32个处理器，，系统的吞吐量损失将超过20%。对于垃圾回收占10%的应用程序，将其拓展至32个处理器时，系统的吞吐量将损失75%以上。如下图所示：

![Description of Figure 1-1 follows](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/img/jsgct_dt_005_gph_pc_vs_tp.png)

​	根据`amdahl定律`，特定问题中并行加速受问题顺序部分的限制，绝大多数工作的负载是不能完全并行化的，某些部分始终是串行的，并不会从并行中收益。对于1.4版本以前的JVM更是如此。

​	故我们在开发小型系统时，速度可以忽略不计的问题，可能会成为拓展到大型系统时的主要瓶颈。对于足够大的系统，选择正确的垃圾收集器，就变得至关重要。

​	串行收集器通常适用于大多数 "小型" 应用程序 (那些需要高达大约100兆字节的堆 (mb (在现代处理器上) 的应用程序。其他收集器具有额外的开销或复杂性, 这是专门行为的代价。如果应用程序不需要备用收集器的专用行为, 请使用串行收集器。串行收集器不应成为最佳选择的一种情况是在具有大量内存和两个或多个处理器的计算机上运行的大型、大量线程化的应用程序。在此类服务器类计算机上运行应用程序时, 默认情况下选择并行收集器。

### 1.2、垃圾收集器类型

- `串行收集器`：使用单线程来执行所有垃圾收集工作，线程之间没有通信开销，故相对高效。适用于单核计算机，因为此类型的收集器不能利用多核处理器硬件，但是该类型的收集器也适用于具有小型数据集（约100MB）的应用程序。显式的开启该收集器，则增加参数`-XX:+UseSerialGC`

- `并行收集器（又称吞吐量收集器）`：并行执行次要收集, 这可以显著降低垃圾收集开销。它适用于在多处理器或多线程硬件上运行的中型到大型数据集的应用程序。显式的开启该收集器，则增加参数`-XX:+UseParallelGC`

- `并行压缩收集器`：使并行收集器能够并行执行主要集合的功能。在没有并行压缩的情况下, 主要集合是使用单个线程执行的, 这可能会显著限制可伸缩性。如果已指定该选项, 则默认情况下启用并行压缩。关闭它的选项是。`-XX:+UseParallelGC-XX:-UseParallelOldGC`

- `并发收集器`：大多数并发收集器同时执行其大部分工作 (例如, 在应用程序仍在运行时)，以保持垃圾收集暂停时间较短。它是为具有中型到大型数据集的应用程序而设计的, 在这些应用程序中, 响应时间比总体吞吐量更重要, 因为用于最大限度地减少暂停的技术可能会降低应用程序性能。java热点虚拟机提供了两个主要是并发的收集器之间的选择;请参阅[主要并发收集器](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/concurrent.html#mostly_concurrent)。使用该选项启用 cms 收集器或启用 G1 收集器。`-XX:+UseConcMarkSweepGC``-XX:+UseG1GC`

### 1.3、如何选择正确的垃圾收集器

## 2、优化

### 2.1、

### 2.2、基于行为的优化

#### 2.2.1、最大暂停时间

#### 2.2.2、吞吐量

#### 2.2.3、内存占用

### 2.3、调优策略

#### 2.3.1、